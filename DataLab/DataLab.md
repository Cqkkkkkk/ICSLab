## DataLab

#### Mod3

考虑k进制数$a$模b的值，存在公式：
$$
a \% b = ((k \% b) (a/k) + (a\% k) ) \% b
$$
对于模以3这种特殊情况，由于10%3=1，上述公式退化为：
$$
a \% b = (a / k + a \% k) \% b
$$
对于十进制数，上式递归展开的结果就是各位的和模以$b$，最后这一步手动操作即可。

而对于二进制数，我们可以将进制位k取4，b取3，带入上式得到
$$
a \% 4 = (a / 4 + a \% 4) \% 3
$$

类似的，递归处理上式之后我们不难发现只需要处理所有两两数位的和能否被3整除即可。最后，对于处理最后一个$\% 4$，我们可以直接通过``&3`来手动处理。

而要得到四进制对应的各位的和，本来我们应该循环处理$a / b + a \% b$直到$a$只有2位，但是在这里我们显然不能使用循环，于是我们可以手动从上而下的完成这个操作。

类似之前提到的，通过循环右移并与低位相加的方法，可以利用二分地算法在较少的操作内统计各位二位的和。

我们以一个8位的数$x_7,x_6,x_5,x_4,x_3,x_2,x_1,x_0$为例子：

- 首先，我们通过循环位移相加把所有的位移动到最后两位：

```c
int mask = (0xff << 8) + 0xff;
int x_sign = x >> 31;
x = (x >> 16) + (x & mask); // 这样做是因为题目要求不能直接用超过0xFF的数
x = (x >> 8) + (x & 0xff);
x = (x >> 4) + (x & 0xf);
x = (x >> 2) + (x & 0x3);
```

- 这时候，我们的8位数变成了形如：

$$
\begin{matrix}
7&6&5&4&3&2&1&0 \\
0&0&0&0&0&0&x_7+x_5+x_3+x_1&x_6+x_4+x_2+x_0
\end{matrix}
$$

- 到这里就不需要移位相加了，因为我们是使用的**4进制**，直接把得到的数与上`0x3`就可以得到在四进制下的各位和，或者说在二进制下的各二位和：

$$
\begin{align*}
\text{sum} &= (2* x_7+x_6)+ (2* x_5+x_4)+ (2* x_3+x_2)+ (2* x_1+x_0) \\
&= 2*(x_7+x_5+x_3+x_1) + (x_6+x_4+x_2+x_0) \\
&= \tt \text{x & 0x3}

\end{align*}
$$

- 但是，这里采用的是直接位相加的模式，不可避免地会出现进位的情况。不妨设这个数的位模式全为1，那么最后会得到形如下式的结果。

$$
\begin{matrix}
7&6&5&4&3&2&1&0 \\
0&0&0&1&0&0&0&0
\end{matrix}
$$

- 考虑到最后是要求各个四进位的和模以3，在这里就是32模以3，我们再次利用上面的方法，通过两次移位量为`2`的移位相加得到其四进位的和：

```c
	x = (x >> 2) + (x & 0x3);
	x = (x >> 2) + (x & 0x3);
```

- 此时得到的数据就是我们需要的值。但是这时候，`x`为负数的值并不对应，这个值需要在`x<0`时减去3，我们希望`-8%3`得到`-2`而不是`1`。同时对应`x=3`时，我们希望它输出0，而不是3。于是有了下面的两条语句：

  ```c
  x = (((x + 1) >> 2) + x) & 0x3;  // 当x = 3时返回0，当x = -3时得到3
  return (x + ~((x_sign & 3) & (~(!!x) + 1)) + 1); // 完整处理
  ```

- 用3数位全为1的特点，将其+1进位后，右移2位。如果为3，则得到的是1。将其再加上x，如若x是1或2，则还是不变，但如果是3，它又会进位到4，那么我们只要再与上0x3，则会得到0，即为想要的结果。

```c
int modThree(int x) {
	int mask = (0xff << 8) + 0xff;
	int x_sign = x >> 31;
	x = (x >> 16) + (x & mask);
	x = (x >> 8) + (x & 0xff);
	x = (x >> 4) + (x & 0xf);
	x = (x >> 2) + (x & 0x3);

	x = (x >> 2) + (x & 0x3);
	x = (x >> 2) + (x & 0x3);
	x = (((x + 1) >> 2) + x) & 0x3;
	return (x + ~((x_sign & 3) & (~(!!x) + 1)) + 1);
}
```

#### ilog2

简单来说，这个题就是求`x`的位模式中第一个`1`离尾端的位置。我们分两部进行，首先把`x`的移位相与到末尾，这样就可以把第一个`1`之后的所有位都置为`1`。记者统计这些`1`的个数，就知道第一个`1`离尾端的位置了。

以一个8位的数$x_7,x_6,x_5,x_4,x_3,x_2,x_1,x_0$为例子：

- 首先将`x`移位相与

  ```c
x |= (x >> 1);
  x |= (x >> 2);
  x |= (x >> 4);
  x |= (x >> 8);
  x |= (x >> 16);
  ```

- 得到下式所示结构，实现了将第一个`1`之后的位全部置为1的结果。

$$
\begin{matrix}
7&6&5&4&3&2&1&0 \\
x_7&x_6&x_5&x_4&x_3&x_2&x_1&x_0 \\
x_7&x_6|x_7&x_5|x_6&x_4|x_5&x_3|x_4&x_2|x_3&x_1|x_2&x_0|x_1 \\
\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots&\vdots& \\
x_7&x_6|x_7&x_5|x_6|x_7&x_4|x_5|x_6|x_7&x_3|x_4|x_5|x_6|x_7 &x_2|x_3|x_4|x_5|x_6|x_7 &x_1|\ldots|x_7&x_0|\ldots|x_7
\end{matrix}
$$

再考虑如何计算有多少个1，仍然以这个八位数为例子，不妨将其实例化为$10101101$:

- 分治地看，这个数分割为8份：$1|0|1|0|1|1|0|1$，每一份内部的1的个数就是每一份对应的值，隔位抽取数字形成两个子串，分别是$1110$和$0011$，对应位相加，每个加法都得到一个2位的结果，得到$01011001$
- 接着将上面得到的数分割为4份：$01|01|10|01$，这时候每一份内部的数的值，也对应上一部相加的两个子部分内的1的数目之和。例如，第三部`10`事实上是由两个`01`相加得到。重复对应位相加，每一个加法都得到一个4位的结果，得到$00110010$。
- 将上面的数分割为2份：$0011|0010$，对应位相加，加法得到八位数的结果：$00000101$，这个结果就是原数据中1的个数。

最后，将1的个数减去1，符合情景。

```c
int ilog2(int x) {
	int mask_tmp, mask1, mask2, mask3, mask4, mask5;
	x |= (x >> 1);
	x |= (x >> 2);
	x |= (x >> 4);
	x |= (x >> 8);
	x |= (x >> 16);

	mask_tmp = (0x55 << 8) + 0x55;
	mask1 = (mask_tmp << 16) + mask_tmp; // 0x55555555
	mask_tmp = (0x33 << 8) + 0x33;
	mask2 = (mask_tmp << 16) + mask_tmp; // 0x33333333
	mask_tmp = (0x0F << 8) + 0x0F;
	mask3 = (mask_tmp << 16) + mask_tmp; // 0x0F0F0F0F
	mask4 = (0xFF << 16) + 0xFF;         // 0x00FF00FF
	mask5 = (0xFF << 8) + 0xFF;          // 0x0000FFFF

	x = (x & mask1) + ((x >> 1) & mask1);
	x = (x & mask2) + ((x >> 2) & mask2);
	x = (x & mask3) + ((x >> 4) & mask3);
	x = (x & mask4) + ((x >> 8) & mask4);
	x = (x & mask5) + ((x >> 16) & mask5);
	
	return x + ~0;
}
```

#### float_i2f

这道题的难点在于，如何处理舍入到偶数的问题。首先，我们将`x`分解为$x = 2^E+\text{frac}$的形式：

```c
while (cnt <= (x / 2)) {
		exp += 1;
		cnt *= 2;
}
```

这里不能用$\tt cnt * 2 <= x$，是因为整数$\tt cnt*2$可能会发生溢出。接下来得到$\text{frac} = x - \tt cnt$。接着考虑将$\tt frac$移位的问题：真正的小数位$\text{frac} = (x - \tt{cnt}) \it >> \rm 23$，但是显然我们这里不可能使用小数表示，于是我们将$\tt exp$的一部分借过来，公式变为：$V = (-1)^s*2^{\exp -150}*(x - {\tt cnt})$，接下来基于$\exp-150$分类讨论

- 当$\exp-150 \geq 0$时，这个做的是乘法，直接将$\text{frac} - {\tt cnt}$左移对应的位数即可。
- 当$\exp-150 <0$时，做除法，需要考虑舍入到偶数的问题。
  - 假设我们要移动$k$位，那么我们首先可以利用一个只有后$k$位为1，其余位为0的$\tt shift\_mask$来得到被移位出去的值：$\tt shift\_away =shift\_mask\, \&\,frac $，尔后将$\tt frac >>= shift\_amount$
  - 接着我们可以基于$\tt shift\_mask$和$\tt shift\_away$讨论：
    - 当$\tt shifted\_away * 2 - shift\_mask - 1 > 0$时，需要向上舍入，$\tt frac+1$
    - 当$\tt shifted\_away * 2 - shift\_mask - 1 == 0$，并且$\tt frac \, \&\, 0x1 == 1$时，需要像偶数舍入，这里也就是向上舍入，$\tt frac+1$
    - 













